//===-- interface.h - Runtime interface declarations ------------*- C++ -*-===//
//
// Part of the LOMP project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
///
/// \file
/// This file contains the definitions of types and functions which are used by the compiler.
/// The original definitions come from the LLVM OpenMP runtime; since our license is the
/// same as the one it uses, and that allows copying, this is fine.
///
//===----------------------------------------------------------------------===//
#ifndef INTERFACE_H_INCLUDED
#define INTERFACE_H_INCLUDED

#include <cstdint>

#include "omp.h"
#include "thunk.h"

/// Masks for fields used in the ident_t.
enum {
  /// Use trampoline for internal microtasks
  KMP_IDENT_IMB = 0x01,
  /// Use c-style ident structure
  KMP_IDENT_KMPC = 0x02,
  // 0x04 is no longer used
  /// Entry point generated by auto-parallelization
  KMP_IDENT_AUTOPAR = 0x08,
  /// Compiler generates atomic reduction option for kmpc_reduce*
  KMP_IDENT_ATOMIC_REDUCE = 0x10,
  /// To mark a 'barrier' directive in user code
  KMP_IDENT_BARRIER_EXPL = 0x20,
  /// To Mark implicit barriers.
  KMP_IDENT_BARRIER_IMPL = 0x0040,
  KMP_IDENT_BARRIER_IMPL_MASK = 0x01C0,
  KMP_IDENT_BARRIER_IMPL_FOR = 0x0040,
  KMP_IDENT_BARRIER_IMPL_SECTIONS = 0x00C0,

  KMP_IDENT_BARRIER_IMPL_SINGLE = 0x0140,
  KMP_IDENT_BARRIER_IMPL_WORKSHARE = 0x01C0,

  /// To mark a static loop in OMPT callbacks
  KMP_IDENT_WORK_LOOP = 0x200,
  /// To mark a sections directive in OMPT callbacks
  KMP_IDENT_WORK_SECTIONS = 0x400,
  /// To mark a distribute construct in OMPT callbacks
  KMP_IDENT_WORK_DISTRIBUTE = 0x800,
  /// Atomic hint; bottom four bits as omp_sync_hint_t. Top four reserved and
  /// not currently used. If one day we need more bits, then we can use
  ///     an invalid combination of hints to mean that another, larger field
  ///     should be used in a different flag.
  KMP_IDENT_ATOMIC_HINT_MASK = 0xFF0000,
  KMP_IDENT_ATOMIC_HINT_UNCONTENDED = 0x010000,
  KMP_IDENT_ATOMIC_HINT_CONTENDED = 0x020000,
  KMP_IDENT_ATOMIC_HINT_NONSPECULATIVE = 0x040000,
  KMP_IDENT_ATOMIC_HINT_SPECULATIVE = 0x080000,
};

/// The source code location structure passed into the runtime in many places.
typedef struct ident {
  int32_t reserved_1;   ///  might be used in Fortran; see above
  int32_t flags;        ///  also f.flags; KMP_IDENT_xxx flags; KMP_IDENT_KMPC
                        /// identifies this union member
  int32_t reserved_2;   ///  not really used in Fortran any more; see above
  int32_t reserved_3;   /// source[4] in Fortran, do not use for C++
  char const * psource; /// String describing the source location.
  /// The string is composed of semi-colon separated fields
  /// which describe the source file, the function and a pair
  /// of line numbers that delimit the construct.
} ident_t;

/// Scheduler enumerations passed into the __kmmpc_for_static_init_* functions.
typedef enum sched_type : int32_t {
  kmp_sch_static_chunked = 33,
  kmp_sch_static = 34, /**< static unspecialized */
  kmp_sch_dynamic_chunked = 35,
  kmp_sch_guided_chunked = 36, /**< guided unspecialized */
  kmp_sch_runtime = 37,        /**< runtime */
  kmp_sch_auto = 38,           /**< auto */
  kmp_sch_imbalanced =
      256, /**< for testing purposes, static steal but with completely imbalanced
                               initial allocation to exercise stealing. */

  /* Support for OpenMP 4.5 monotonic and nonmonotonic schedule modifiers. Since
     we need to distinguish the three possible cases (no modifier, monotonic
     modifier, nonmonotonic modifier), we need separate bits for each modifier.
     The absence of monotonic does not imply nonmonotonic, especially since 4.5
     says that the behavior of the "no modifier" case is implementation defined
     in 4.5, but will become "nonmonotonic" in 5.0.

     Since we're passing a full 32 bit value, we can use a couple of high bits
     for these flags; out of paranoia we avoid the sign bit.

     These modifiers can be or-ed into non-static schedules by the compiler to
     pass the additional information. They will be stripped early in the
     processing in __kmp_dispatch_init when setting up schedules, so most of the
     code won't ever see schedules with these bits set.  */
  kmp_sch_modifier_monotonic =
      (1 << 29), /**< Set if the monotonic schedule modifier was present */
  kmp_sch_modifier_nonmonotonic =
      (1 << 30), /**< Set if the nonmonotonic schedule modifier was present */

#define SCHEDULE_WITHOUT_MODIFIERS(s)                                          \
  (enum sched_type)(                                                           \
      (s) & ~(kmp_sch_modifier_nonmonotonic | kmp_sch_modifier_monotonic))
#define SCHEDULE_HAS_MONOTONIC(s) (((s)&kmp_sch_modifier_monotonic) != 0)
#define SCHEDULE_HAS_NONMONOTONIC(s) (((s)&kmp_sch_modifier_nonmonotonic) != 0)
#define SCHEDULE_HAS_NO_MODIFIERS(s)                                           \
  (((s) & (kmp_sch_modifier_nonmonotonic | kmp_sch_modifier_monotonic)) == 0)
#define SCHEDULE_GET_MODIFIERS(s)                                              \
  ((enum sched_type)((s) & (kmp_sch_modifier_nonmonotonic |                    \
                            kmp_sch_modifier_monotonic)))
} kmp_sched_t;

extern "C" {

// Parallelism entry points
void __kmpc_push_num_threads(ident_t *, int32_t, int32_t nthreads);
void __kmpc_fork_call(ident_t *, int32_t, lomp::BodyTypeLLVM, ...);
void __kmpc_barrier(ident_t *, int32_t);
int32_t __kmpc_global_thread_num(ident_t *);
int32_t __kmpc_in_parallel(ident_t *);

// Tasking entry points
void * __kmp_task_alloc(ident_t *, int32_t gtid, void * flags,
                        size_t sizeOfTaskClosure, size_t sizeOfShareds,
                        void * thunk);
int32_t __kmpc_omp_task(ident_t *, int32_t gtid, void * new_task);
int32_t __kmpc_omp_taskwait(ident_t *, int32_t);
int32_t __kmpc_taskgroup(ident_t *, int32_t);
int32_t __kmpc_end_taskgroup(ident_t *, int32_t);

// Entry points for serialization constructs
int32_t __kmpc_single(ident_t *, int32_t *);
void __kmpc_end_single(ident_t *, int32_t);
int32_t __kmpc_master(ident_t *, int32_t);
void __kmpc_end_master(ident_t *, int32_t);

// Lock-related entry points
void __kmpc_critical(ident_t *, int32_t, void *);
void __kmpc_critical_with_hint(ident_t *, int32_t, void *, uint32_t);
void __kmpc_end_critical(ident_t *, int32_t, void *);

#if (LOMP_GNU_SUPPORT)
void GOMP_parallel(void (*)(void *), void *, unsigned);
void GOMP_barrier(void);
void GOMP_task(void (*)(void *), void *, void (*)(void *, void *), long, long,
               bool, unsigned, void **);
void GOMP_taskwait(void);
void GOMP_taskgroup_start(void);
void GOMP_taskgroup_end(void);
int GOMP_single_start(void);
void GOMP_loop_end();
void GOMP_loop_maybe_nonmonotonic_runtime_start();
void GOMP_loop_maybe_nonmonotonic_runtime_next();
void GOMP_critical_start(void);
void GOMP_critical_end(void);
void GOMP_critical_name_start(void **);
void GOMP_critical_name_end(void **);
#endif

// Functions called by the Intel compiler, but not LLVM! These are either empty,
// or abort if called, but having the entrypoints allows us to link with
// Intel-compiled code and run as long as some features are not used.
#if (LOMP_ICC_SUPPORT)
void __kmpc_begin(ident_t *, int32_t);
int32_t __kmpc_ok_to_fork(ident_t *);
void __kmpc_serialized_parallel(ident_t *, int32_t);
void __kmpc_end_serialized_parallel(ident_t *, int32_t);
void __kmpc_end(ident_t *);
void __kmpc_init_lock(ident_t *, int32_t, void **);
void __kmpc_set_lock(ident_t *, int32_t, void **);
void __kmpc_unset_lock(ident_t *, int32_t, void **);
void __kmpc_destroy_lock(ident_t *, int32_t, void **);
#endif

} // extern "C"

#endif
